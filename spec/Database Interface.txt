   === Radiance Database Interface Specification ===

  == Terminology ===

Even though the terminology between specific databases may vary,
in this document the following words are used:
  field        A cell or single atom containing a value
  record       A set of fields
  collection   A set of records
  database     A set of collections or
               The mechanism providing data
  query        A construct used to interface with the database

  == Usage ==

 = Database = 

A module should be shielded from any direct database interaction.
Any kind of querying or modifying should only happen through the
defined functions on the database interface. The module should
not have to worry about database connectivity.

If a module intends to read data from a collection, it can do so
without having to assure that the requested collection exists. If
it does not exist, the querying functions should merely return an
empty set.

However, a module that intends to insert or modify data has to
issue a db-create statement first and specify the standard
structure of the collection. Whether this structure is flexible
or fixed is up to the implementation, but the using module
should assume that it is not flexible.

When requesting data, the db-iterate function should be used
wherever possible, as it may be significantly more performant at
best and only slightly less performant than db-select at worst.

Queries are constructed by the query macro, which should
recognize the and or not = < > >= <= in matches
instructions. Alternatively the keyword :all can also be used
to simply retrieve any record.

The querying functions also allow the specification of requested
fields. This might speed up data transfer on some databases, but
the implementation is not required to acknowledge this parameter.

The sort parameter in query functions has to be a list of cons
cells, the car of which is the field and the cdr the order of
sorting. The order can be either :ASC or :DESC or 1 and -1
respectively.

When defining a collection with db-create, each field has to be
defined with a name, type and optional length. Certain database
implementations may choose to ignore these types, but they are a
necessity for others and as such should always be explicitly
stated. Optionally, a list of indexed fields may be specified.

Example:

(unless (db-exists T "example")
  (db-create T "example"
    '(("ID" :int) ("title" :char 16) ("text" :text))
    '("ID")))

(db-select T "example" :all)
(db-insert T "example" '(("ID" . 1) ("title" . "test") ("text" . "Foo Bar Baz")))
(db-select T "example" (query (= "ID" 1)))
(db-update T "example" (query (= "ID" 1)) '(("title" "test^2")))
(db-iterate T "example" #'(lambda (record) (print record)))
(db-remove T "example" :all)
(db-select T "example" :all)

 = Data-Model =

Data models provide a more intuitive way to interact with the
database by putting a thin layer of abstraction above database
functions. 

Data-Models are retrieved with model-get and model-get-one. The
query used is the same as with a standard db-select, but instead
the data gets returned in form of data-model instances. All fields
are available through model-field and should be setf-able.

In order to update records, simply perform a model-save on the
instance. Removing a record happens with model-delete. If you do
not already have a hold of the model, executing a db-remove would
be recommended, as it avoids unnecessary data transfer and querying.

Any model can be inserted into the database as a new record by
using model-insert. In order to create completely new records, a
hull may be created instead with model-hull. If :clone T is
supplied to model-insert, the model is cloned first and the old
model is returned from the function. Otherwise, the model will
refer to the newly created record.

Easy access to model fields is provided through the with-fields
macro, which is similar in functionality to the with-accessors
CLOS macro. The model is not saved to the database at any point
though, so if changes are made through a with-fields block, an
additional model-save has to be executed.

Easy access to a single model is provided through the with-model
macro. It also integrates the functionality of with-fields, so
it is very convenient for single-model adaptations. The return
value of with-model and with-fields is always the value of the
last statement in their body.

Example:

(with-model (model title (content "text")) ("example" (query (= "ID" 1)) :save T)
  (setf title "Testing stuff")
  content)

(with-model model ("example" (query (= "ID" 1)))
  (db-remove model))
  
