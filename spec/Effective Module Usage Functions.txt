---------------------------------------------------------
 == EFFECTIVE MODULE USAGE FUNCTIONS ==


MACRO (implemented):
(in-module :bla)
  => module and package set

Sets *module* to the current module, much like in-package.
Side effect: Also executes in-package to set it to the module's package.


FUNCTION (implemented):
(make-uri urispec) => uri

Creates a URI object matching the urispec. Urispec has the following
syntax:  (subdomain.)*domain?:port?/path?
The following are all valid examples:
"foo.bar:80/baz"
"bar:80/baz"
"foo.bar/baz"
"foo./baz"
"foo.:80/baz"
"/"
"/foo"
If a part of the URI is not given, it is defaulted to "*", which
matches to anything. make-uri has a read-macro for easier use: #u


MACRO (implemented):
(defpage name uri (&key (module *module*) access-branch lquery (dispatcher T))
  &rest body) => page definition

Defines a new page for the given module that will be available on the
specified URI. If access-branch is given, an authorization check on the
current session at page load will be performed. If lquery is non-NIL,
lQuery will be initialized with the given pathspec and the page output
will be set to the lQuery serialization, unless the response field of
the *radiance-request* is already set. If lQuery is unset, the return
value of the request is automatically chosen.


MACRO (implemented):
(defapi name (&rest args) (&key (module *module*) access-branch)
  &rest body) => api definition

Defines a new API function for the given module. The arguments specify
REST values that are expected (or not according to definition) on the
API call. Any variable can have a default value specified. If 
access-branch is given, an authorization check on the current session
at page load will be performed. The return value of the body should be
an alist or an URI. This will automatically be transformed into the
requested output type or a page redirect in the case of an URI.


FUNCTION (implemented):
(api-return code text 
  &rest plist-data) => alist

Generates an API response in the proper format:
((:CODE . code) (:TEXT . text) (:DATA . data))
Additional data is changed from a plist into an alist automatically.


FUNCTION:
(define-file-link name uri pathspec &key access-branch) 
  => link definition

Defines a link of a given URI to a file. Useful for things like
favicon.ico, robots.txt, humans.txt or other files that cannot be in
the static/ directory.


FUNCTION (implemented):
(link name &key (module *module*) (type :URI)) 
  => type

Returns the link to the requested page or API function. Type can
be one of the following values: :URI :function :hook.


MACRO (implemented):
(with-get (&rest vars)
  &rest body) => variable closure

Same as with-slots, but for GET variables.
Uses *radiance-request* to retrieve variables.
Note that changes to the variables will not be saved
in the actual request and are therefore purely temporary.


MACRO (implemented):
(with-post (&rest vars)
  &rest body) => variable closure

Same as with-slots, but for POST variables.
Uses *radiance-request* to retrieve variables.
Note that changes to the variables will not be saved
in the actual request and are therefore purely temporary.

---------------------------------------------------------
 == USAGE CASES ==

 = Example 1: Voting Application = 

(in-module :vote)

(define-file-link favicon #u"vote./favicon.ico" (static "vote/favicon.ico"))

(defpage vote #u"vote." (:lquery (template "vote/vote.html"))
  (let ((options (model-get T "vote" :all)))
    (uibox:fill-foreach options "ul#options"))
  (unless (authenticated-p)
    ($ "input[type=\"submit\"]" (attr :disabled "disabled"))))

(defapi vote (option) (:access-branch "*")
  (let ((model (model-get-one T "vote" (:= "name" option))))
    (if model
        (with-fields (votes) model 
          (setf votes (1+ votes))
          (model-save model))
        (error 'api-invalid-argument-error :text (format nil "Invalid option ~a selected." option))))
  (link 'votey))


 = Example 2: User-Bound ToDo List = 

(in-module :todo)

(define-file-link favicon #u"todo./favicon.ico" (static "todo/favicon.ico"))

(defpage todo #u"todo." (:lquery (template "todo/todo.html") :access-branch "todo.*")
  (let ((todos (model-get T "todo" (:= "user" (username (session-user *radiance-session*))))))
    (uibox:fill-foreach todos "ul#todos")))

(defapi add-todo (text) (:access-branch "todo.add")
  (let ((model (model-hull T "todo")))
    (with-fields (id user textf time) model
      (setf id (make-uuid) 
            user (username (session-user *radiance-session*))
            textf text
            time (get-unix-time))
      (model-save model))
      (api-return 200 "Todo added." :id id :text text :time time)))

(defapi del-todo (uuid) (:access-branch "todo.del")
  (let ((model (model-get-one T "todo" (:and (:= "id" uuid) (:= "user" (username (session-user *radiance-session*)))))))
    (if model
        (with-fields (id) model
          (model-delete model)
          (api-return 200 "Todo deleted." :id id)

        (error 'api-invalid-argument-error :text (format nil "Todo with ID ~a does not exist!" uuid)))))

(defapi edit-todo (uuid text) (:access-branch "todo.edit")
  (let ((model (model-get-one T "todo" (:and (:= "id" uuid) (:= "user" (username (session-user *radiance-session*)))))))
    (if model
        (with-fileds (textf time) 
          (setf textf text)
          (model-save model)
          (api-return 200 "Todo edited." :id id :text text :time time))

        (error 'api-invalid-argument-error :text (format nil "Todo with ID ~a does not exist!" uuid)))))
